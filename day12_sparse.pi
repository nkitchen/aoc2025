import aoc.
import os.
import util.
import smt.

main([File]) =>
    go(File).

go(File) =>
    Input = read_file_lines(File),
    [Shapes, Regions] = parse_presents(Input),
    part1(Shapes, Regions),
    true.

parse_presents(Lines) = [Shapes, Regions] =>
    Blocks = line_blocks(Lines),
    Shapes = map(parse_shape, Blocks[1..length(Blocks)-1]),
    Regions = map(parse_region, last(Blocks)).

line_blocks(Lines) = Blocks =>
    LinesA = to_array(Lines),
    BlankIdxs = [0] ++ [I : I in 1..length(LinesA), LinesA[I] == ""] ++ [LinesA.length + 1],
    BlockDelims = window2(BlankIdxs),
    Blocks = [to_list(LinesA[I+1..J-1]) : [I, J] in BlockDelims].

parse_shape(Lines) = Shape =>
    % We don't need the line with the shape index.
    L = [map(shape_cell, Line) : Line in Lines.slice(2)],
    Shape = list_matrix_to_array_matrix(L).

shape_cell('.') = 0.
shape_cell('#') = 1.

parse_region(Line) = [Dims, ShapeCounts] =>
    find(Line, ": ", ColonFrom, ColonTo),
    DimsStr = Line[1..(ColonFrom - 1)],
    CountsStr = Line.slice(ColonTo + 1),
    Dims = reverse(map(to_number, DimsStr.split("x"))),
    ShapeCounts = map(to_number, CountsStr.split()).

part1(Shapes, Regions) =>
    Variants = map(make_variants, Shapes),
    ShapeWeights = map(sum, Shapes),
    Fits = [R : R in Regions, fit(Variants, ShapeWeights, R)],
    printf("Part 1: %ld\n", Fits.length),
    true.

make_variants(Shape) = Variants =>
    Turned = [Shape],
    while (Turned.length < 4)
        Turned := [turn(first(Turned))|Turned]
    end,
    WithHFlips = flatten([[V, flip_horiz(V)] : V in Turned]),
    WithVFlips = flatten([[V, flip_vert(V)] : V in WithHFlips]),
    Seen = new_set(),
    Variants = [],
    foreach (V in WithVFlips)
        S = to_string(V),
        if (not Seen.has_key(S))
            Variants := [V|Variants],
            Seen.put(S)
        end
    end.

turn(V) = T =>
    M = V.length,
    N = V[1].length,
    T = {{V[I, J] : I in M..-1..1} : J in 1..N}.
flip_horiz(V) = map_array(reverse, V).
flip_vert(V) = V.transpose().flip_horiz().transpose().

easy_no(ShapeWeights, Region) =>
    S = ShapeWeights.length,
    [[M, N], ShapeCounts] = Region,
    ShapeCounts.length == S,
    K = 3,
    
    TotalWeight = sum([W * C : {W, C} in zip(ShapeWeights, ShapeCounts)]),
    TotalWeight > M * N.

easy_yes(Region) =>
    [[M, N], ShapeCounts] = Region,
    S = ShapeCounts.length,
    K = 3,

    sum(ShapeCounts) <= (M // K) * (N // K).

fit(Variants, ShapeWeights, Region), easy_no(ShapeWeights, Region) =>
    false.

fit(Variants, ShapeWeights, Region), easy_yes(Region) =>
    true.
    
fit(Variants, ShapeWeights, Region) =>
    S = Variants.length,
    [[M, N], ShapeCounts] = Region,
    ShapeCounts.length == S,
    K = length(Variants[1, 1]),
    K == 3,

    ShapeId = new_array(S),
    NextShapeId = 1,
    foreach (I in 1..S)
        ShapeId[I] = new_array(ShapeCounts[I]),
        foreach (J in 1..length(ShapeId[I]))
            ShapeId[I, J] := NextShapeId,
            NextShapeId := NextShapeId + 1
        end
    end,
    MaxShapeId = NextShapeId - 1,

    V = max(map(length, Variants)),

    println(M * N * MaxShapeId * V),
    GridVar = new_array(M, N, MaxShapeId, V),
    foreach (I in 1..M, J in 1..N, SId in 1..MaxShapeId)
        foreach (VarI in 1..V)
            GridVar :: 0..1
        end,
        sum([GridVar[I, J, SId, VarI] : VarI in 1..V]) #= 1
    end,
        
    solve([GridVar]),
    %println(InstVariant),
    %println(Pos),
    %foreach (I in 1..M)
    %    println(Grid[I])
    %end,
    true.

% ===> multitime results (with GLPK installed)
% 1: picat day10.pi in10.txt
%             Mean        Std.Dev.    Min         Median      Max
% real        2.204       0.000       2.204       2.204       2.204
% user        1.299       0.000       1.299       1.299       1.299
% sys         0.897       0.000       0.897       0.897       0.897
