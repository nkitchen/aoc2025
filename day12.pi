import aoc.
import os.
import util.
import cp.

main([File]) =>
    go(File).

go(File) =>
    Input = read_file_lines(File),
    [Shapes, Regions] = parse_presents(Input),
    part1(Shapes, Regions),
    true.

parse_presents(Lines) = [Shapes, Regions] =>
    Blocks = line_blocks(Lines),
    Shapes = map(parse_shape, Blocks[1..length(Blocks)-1]),
    Regions = map(parse_region, last(Blocks)).

line_blocks(Lines) = Blocks =>
    LinesA = to_array(Lines),
    BlankIdxs = [0] ++ [I : I in 1..length(LinesA), LinesA[I] == ""] ++ [LinesA.length + 1],
    BlockDelims = window2(BlankIdxs),
    Blocks = [to_list(LinesA[I+1..J-1]) : [I, J] in BlockDelims].

parse_shape(Lines) = Shape =>
    % We don't need the line with the shape index.
    L = [map(shape_cell, Line) : Line in Lines.slice(2)],
    Shape = list_matrix_to_array_matrix(L).

shape_cell('.') = 0.
shape_cell('#') = 1.

parse_region(Line) = [Dims, ShapeCounts] =>
    find(Line, ": ", ColonFrom, ColonTo),
    DimsStr = Line[1..(ColonFrom - 1)],
    CountsStr = Line.slice(ColonTo + 1),
    Dims = reverse(map(to_number, DimsStr.split("x"))),
    ShapeCounts = map(to_number, CountsStr.split()).

part1(Shapes, Regions) =>
    Variants = map(make_variants, Shapes),
    ShapeWeights = map(sum, Shapes),
    Fits = [R : R in Regions, fit(Variants, ShapeWeights, R)],
    printf("Part 1: %ld\n", Fits.length),
    true.

make_variants(Shape) = Variants =>
    Turned = [Shape],
    while (Turned.length < 4)
        Turned := [turn(first(Turned))|Turned]
    end,
    WithHFlips = flatten([[V, flip_horiz(V)] : V in Turned]),
    WithVFlips = flatten([[V, flip_vert(V)] : V in WithHFlips]),
    Seen = new_set(),
    Variants = [],
    foreach (V in WithVFlips)
        S = to_string(V),
        if (not Seen.has_key(S))
            Variants := [V|Variants],
            Seen.put(S)
        end
    end.

turn(V) = T =>
    M = V.length,
    N = V[1].length,
    T = {{V[I, J] : I in M..-1..1} : J in 1..N}.
flip_horiz(V) = map_array(reverse, V).
flip_vert(V) = V.transpose().flip_horiz().transpose().

easy_no(ShapeWeights, Region) =>
    S = ShapeWeights.length,
    [[M, N], ShapeCounts] = Region,
    ShapeCounts.length == S,
    K = 3,
    
    TotalWeight = sum([W * C : {W, C} in zip(ShapeWeights, ShapeCounts)]),
    TotalWeight > M * N.

easy_yes(Region) =>
    [[M, N], ShapeCounts] = Region,
    S = ShapeCounts.length,
    K = 3,

    sum(ShapeCounts) <= (M // K) * (N // K).

fit(Variants, ShapeWeights, Region), easy_no(ShapeWeights, Region) =>
    false.

fit(Variants, ShapeWeights, Region), easy_yes(Region) =>
    true.
    
fit(Variants, ShapeWeights, Region) =>
    S = Variants.length,
    [[M, N], ShapeCounts] = Region,
    ShapeCounts.length == S,
    K = length(Variants[1, 1]),
    K == 3,
    MaxVariants = max(map(length, Variants)),

    ShapeInst = new_array(M, N),
    VariantInst = new_array(M, N),
    ShapeOrigin = new_array(M, N, 2), % The location of the shape filling each cell
    foreach (I in 1..M, J in 1..N)
        ShapeInst[I, J] :: 0..S,
        VariantInst[I, J] :: 0..MaxVariants,
        ShapeOrigin[I, J, 1] :: 0..(M - K + 1),
        ShapeOrigin[I, J, 2] :: 0..(N - K + 1),
 
        foreach (IShape in 1..S)
            if (ShapeCounts[IShape] == 0)
                ShapeInst[I, J] #!= IShape
            else
                MaxVar = length(Variants[IShape]),
                (ShapeInst[I, J] #= IShape) #=>
                    (1 #<= VariantInst[I, J] #/\ VariantInst[I, J] #<= MaxVar)
            end
        end,
        (ShapeInst[I, J] #= 0) #=> (VariantInst[I, J] #= 0),

        if (I + K - 1 > M || J + K - 1 > N)
            ShapeInst[I, J] #= 0
        end
    end,

    ShapeInstList = [ShapeInst[I, J] : I in 1..M, J in 1..N],
    foreach (IShape in 1..S)
        count(IShape, ShapeInstList) #= ShapeCounts[IShape],
    end,

    foreach (IShape in 1..S, ShapeCounts[IShape] > 0)
        foreach (I in 1..(M-K+1), J in 1..(N-K+1))
            foreach (JVariant in 1..length(Variants[IShape]))
                foreach (DI in 1..K, DJ in 1..K)
                    if (Variants[IShape, JVariant, DI, DJ] == 1)
                       (ShapeInst[I, J] #= IShape #/\ VariantInst[I, J] #= JVariant)
                           #=>
                           ShapeOrigin[I+DI-1, J+DJ-1, 1] #= I,
                       (ShapeInst[I, J] #= IShape #/\ VariantInst[I, J] #= JVariant)
                           #=>
                           ShapeOrigin[I+DI-1, J+DJ-1, 2] #= J
                    end
                end
            end
        end
    end,
 
    printf("Solving region %s\n", to_string(Region)),
    solve($[ffc], [ShapeInst, VariantInst, ShapeOrigin]),
    %solve($[sat], [ShapeInst, VariantInst, ShapeOrigin]),
    %solve($[smt(cvc4)], [ShapeInst, VariantInst, ShapeOrigin]),
    %solve($[cp], [ShapeInst, VariantInst, ShapeOrigin]),
    printf("Solved region %s\n", to_string(Region)),

    dprintf("ShapeInst:\n"),
    foreach (I in 1..M)
        foreach (J in 1..N)
            dprintf("%2d ", ShapeInst[I, J])
        end,
        dprintf("\n")
    end,
    dprintf("\n"),

    dprintf("VariantInst:\n"),
    foreach (I in 1..M)
        foreach (J in 1..N)
            dprintf("%2d ", VariantInst[I, J])
        end,
        dprintf("\n")
    end,
    dprintf("\n"),

    dprintf("ShapeOrigin:\n"),
    foreach (I in 1..M)
        foreach (J in 1..N)
            dprintf("%02d,%02d ", ShapeOrigin[I, J, 1], ShapeOrigin[I, J, 2])
        end,
        dprintf("\n")
    end,
    dprintf("\n"),

    true.

% ===> multitime results
% 1: picat day12.pi in12.txt
%             Mean        Std.Dev.    Min         Median      Max
% real        0.086       0.000       0.086       0.086       0.086
% user        0.055       0.000       0.055       0.055       0.055
% sys         0.030       0.000       0.030       0.030       0.030
